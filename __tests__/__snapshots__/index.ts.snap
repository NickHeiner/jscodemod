// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TS compilation flags Path to TSC is specified 1`] = `
Object {
  "codemod/index.ts": "import {Codemod} from 'jscodemod';

// Compiling this will not work automatically, because no TSC will be found.

const codemod: Codemod = {
  transform({source}) {
    return \`/* prefix no-tsc */\\\\n\${source}\`;
  }
};

export default codemod;",
  "input.js": "/* prefix no-tsc */
module.exports = {
  input: 'file'
};",
}
`;

exports[`TS compilation flags Specified tsconfig path 1`] = `
Object {
  "codemod/index.ts": "import {Codemod} from 'jscodemod';

// Compiling this will not work, because no TSC will be found.

const codemod: Codemod = {
  transform({source}) {
    return \`/* prefix tsconfig-non-standard-location */\\\\n\${source}\`;
  }
};

export default codemod;",
  "configs/tsconfig.json": "{
  \\"include\\": [\\"../codemod/*.ts\\"],

  \\"compilerOptions\\": {
    \\"target\\": \\"ES2019\\",
    \\"module\\": \\"commonjs\\",
    \\"strict\\": true,

    \\"rootDir\\": \\"..\\",

    \\"outDir\\": \\"should-be-ignored\\",
    
    \\"noUnusedLocals\\": true,
    \\"noUnusedParameters\\": true,
    \\"noImplicitReturns\\": true, 
    \\"noFallthroughCasesInSwitch\\": true,

    \\"moduleResolution\\": \\"node\\",
    \\"esModuleInterop\\": true,

    \\"skipLibCheck\\": true,
    \\"forceConsistentCasingInFileNames\\": true
  }
}
",
  "input.js": "/* prefix tsconfig-non-standard-location */
const file = 'asdf';",
}
`;

exports[`git Modify dirty files 1`] = `
Object {
  "codemod/codemod.js": "module.exports = {
  transform({source}) {
    return \`/* prefix git dirty */\\\\n\${source}\`;
  }
};",
  "git-ignored.js": "console.log('git ignored');
",
  "git-untracked.js": "",
  "source/dirty.js": "/* prefix git dirty */
const x = 'dirty state';",
  "source/nested-git-ignored.js": "console.log('nested git ignored');",
  "source/unmodified.js": "/* prefix git dirty */
const x = 'starting state';",
}
`;

exports[`git Reset dirty files 1`] = `
Object {
  "codemod/codemod.js": "module.exports = {
  transform({source}) {
    return \`/* prefix git dirty */\\\\n\${source}\`;
  }
};",
  "git-ignored.js": "console.log('git ignored');
",
  "git-untracked.js": "",
  "source/dirty.js": "/* prefix git dirty */
const x = 'starting state';",
  "source/nested-git-ignored.js": "console.log('nested git ignored');",
  "source/unmodified.js": "/* prefix git dirty */
const x = 'starting state';",
}
`;

exports[`happy path TS without manually specifying any of the args determining how to compile 1`] = `
Object {
  "codemod/babel-plugin.ts": "import * as BabelTypes from '@babel/types';
import {Visitor} from '@babel/traverse';

// TODO is our intentional any type.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type TODO = any;

export default ({types: t}: {types: typeof BabelTypes}): {visitor: Visitor<TODO>} => 
  ({
    visitor: {
      ArrowFunctionExpression(path) {
        if (t.isBlockStatement(path.node.body) && path.node.body.body.length === 1 &&
              t.isReturnStatement(path.node.body.body[0])) {

          // I'm confident that this value will not be null, based on the runtime checks above.
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          path.get('body').replaceWith(path.node.body.body[0].argument!);  
        }
      }
    }
  });",
  "codemod/index.ts": "import {Codemod} from 'jscodemod';
import babelPlugin from './babel-plugin';
import {transformSync} from '@babel/core';

const codemod: Codemod = {
  transform({source, filePath}) {
    return transformSync(source, {
      filename: filePath,
      plugins: ['@babel/plugin-syntax-optional-chaining', babelPlugin],
      ast: true
    })?.code;
  }
};

export default codemod;",
  "source/optional-chaining.js": "const g = a => a?.b?.c?.d;",
  "source/ts.ts": "const f = () => 1;",
}
`;

exports[`happy path dry 1`] = `
Object {
  "codemod/codemod.js": "module.exports = {
  transform({source}) {
    return \`/* prefix prepend string */\\\\n\${source}\`;
  }
};",
  "codemod/jscodeshift-codemod.js": "module.exports = ({source}) => \`/* prefix */\\\\n\${source}\`;",
  "source/a.js": "console.log('a');",
  "source/b.js": "function b() {}",
  "source/blank.js": "",
}
`;

exports[`happy path prepend-string 1`] = `
Object {
  "codemod/codemod.js": "module.exports = {
  transform({source}) {
    return \`/* prefix prepend string */\\\\n\${source}\`;
  }
};",
  "codemod/jscodeshift-codemod.js": "module.exports = ({source}) => \`/* prefix */\\\\n\${source}\`;",
  "source/a.js": "/* prefix prepend string */
console.log('a');",
  "source/b.js": "/* prefix prepend string */
function b() {}",
  "source/blank.js": "/* prefix prepend string */
",
}
`;
